<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SPAKE2 E2E Test</title>
    <style>
      :root {
        color-scheme: light;
        font-family:
          'SF Mono', 'Menlo', 'Consolas', 'Liberation Mono', monospace;
      }

      body {
        margin: 0;
        padding: 24px;
        background: #f8fafc;
        color: #0f172a;
      }

      main {
        max-width: 980px;
        margin: 0 auto;
        background: #ffffff;
        border: 1px solid #cbd5e1;
        border-radius: 10px;
        padding: 20px;
      }

      h1 {
        margin-top: 0;
        font-size: 24px;
      }

      p {
        margin-top: 0;
      }

      .row {
        display: grid;
        gap: 12px;
        margin-bottom: 12px;
      }

      label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 6px;
      }

      .field-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 6px;
      }

      input,
      textarea,
      button {
        font: inherit;
        width: 100%;
        box-sizing: border-box;
      }

      input,
      textarea {
        border: 1px solid #94a3b8;
        border-radius: 6px;
        padding: 8px;
        background: #ffffff;
      }

      textarea {
        min-height: 72px;
        resize: vertical;
      }

      button {
        width: auto;
        border: 1px solid #1d4ed8;
        border-radius: 6px;
        background: #2563eb;
        color: #ffffff;
        padding: 10px 14px;
        cursor: pointer;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      pre {
        margin: 0;
        min-height: 220px;
        padding: 12px;
        background: #0f172a;
        color: #e2e8f0;
        border-radius: 8px;
        overflow: auto;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>SPAKE2 Trusted-Key E2E Test</h1>
      <p>
        This page runs:
        <code>/api/auth/trusted-keys/spake2/start</code>,
        <code>/api/auth/trusted-keys/spake2/finish</code>, then
        <code>/api/auth/signed-test</code> with the newly generated key.
      </p>

      <form id="runForm">
        <div class="row">
          <label for="password">Enrollment Password</label>
          <input
            id="password"
            type="password"
            autocomplete="off"
            placeholder="Value of VK_TRUSTED_KEYS_ENROLL_PASSWORD"
          />
        </div>

        <div class="row">
          <button id="run" type="submit">Run E2E Test</button>
        </div>
      </form>

      <div class="row">
        <label for="publicKey">Generated Public Key (base64, 32 bytes)</label>
        <textarea id="publicKey" readonly></textarea>
      </div>

      <div class="row">
        <label for="privateKey">Generated Private Key (base64, 32-byte seed)</label>
        <textarea id="privateKey" readonly></textarea>
      </div>

      <div class="row">
        <label for="enrollmentId">Enrollment ID</label>
        <input id="enrollmentId" readonly />
      </div>

      <div class="row">
        <div class="field-label">Logs</div>
        <pre id="logs"></pre>
      </div>
    </main>

    <script type="module">
      import { ed25519 } from 'https://cdn.jsdelivr.net/npm/@noble/curves@1.9.7/ed25519/+esm';

      const encoder = new TextEncoder();
      const ED25519_ORDER = ed25519.CURVE.n;
      const CLIENT_ID = encoder.encode('vibe-kanban-browser');
      const SERVER_ID = encoder.encode('vibe-kanban-server');
      const CLIENT_PROOF_CONTEXT = encoder.encode('vk-spake2-client-proof-v1');
      const SERVER_PROOF_CONTEXT = encoder.encode('vk-spake2-server-proof-v1');
      const SPAKE2_M = ed25519.ExtendedPoint.fromHex(
        '15cfd18e385952982b6a8f8c7854963b58e34388c8e6dae891db756481a02312'
      );
      const SPAKE2_N = ed25519.ExtendedPoint.fromHex(
        'f04f2e7eb734b2a8f8b472eaf9c3c632576ac64aea650b496a8a20ff00e583c3'
      );

      const runForm = document.querySelector('#runForm');
      const runButton = document.querySelector('#run');
      const passwordInput = document.querySelector('#password');
      const publicKeyField = document.querySelector('#publicKey');
      const privateKeyField = document.querySelector('#privateKey');
      const enrollmentIdField = document.querySelector('#enrollmentId');
      const logsField = document.querySelector('#logs');

      runForm.addEventListener('submit', (event) => {
        event.preventDefault();
        runE2e().catch((error) => {
          log(`ERROR: ${error instanceof Error ? error.message : String(error)}`);
        });
      });

      function log(message) {
        const timestamp = new Date().toISOString();
        logsField.textContent += `[${timestamp}] ${message}\n`;
        logsField.scrollTop = logsField.scrollHeight;
      }

      function resetOutput() {
        logsField.textContent = '';
        publicKeyField.value = '';
        privateKeyField.value = '';
        enrollmentIdField.value = '';
      }

      function bytesToBase64(bytes) {
        let binary = '';
        for (let i = 0; i < bytes.length; i += 1) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      function base64ToBytes(input) {
        const binary = atob(input);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function concatBytes(...parts) {
        const totalLength = parts.reduce((sum, bytes) => sum + bytes.length, 0);
        const output = new Uint8Array(totalLength);
        let offset = 0;
        for (const bytes of parts) {
          output.set(bytes, offset);
          offset += bytes.length;
        }
        return output;
      }

      function equalBytes(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        let diff = 0;
        for (let i = 0; i < a.length; i += 1) {
          diff |= a[i] ^ b[i];
        }
        return diff === 0;
      }

      function bytesToBigIntLe(bytes) {
        let value = 0n;
        for (let i = bytes.length - 1; i >= 0; i -= 1) {
          value = (value << 8n) + BigInt(bytes[i]);
        }
        return value;
      }

      function modOrder(value) {
        const result = value % ED25519_ORDER;
        return result >= 0n ? result : result + ED25519_ORDER;
      }

      function scalarNeg(scalar) {
        return scalar === 0n ? 0n : ED25519_ORDER - scalar;
      }

      function randomScalar() {
        while (true) {
          const randomBytes = crypto.getRandomValues(new Uint8Array(64));
          const scalar = modOrder(bytesToBigIntLe(randomBytes));
          if (scalar !== 0n) {
            return scalar;
          }
        }
      }

      function parseUuidBytes(uuid) {
        const hex = uuid.replace(/-/g, '').toLowerCase();
        if (!/^[0-9a-f]{32}$/.test(hex)) {
          throw new Error(`Invalid UUID: ${uuid}`);
        }
        const bytes = new Uint8Array(16);
        for (let i = 0; i < 16; i += 1) {
          bytes[i] = Number.parseInt(hex.slice(i * 2, i * 2 + 2), 16);
        }
        return bytes;
      }

      async function sha256(data) {
        const digest = await crypto.subtle.digest('SHA-256', data);
        return new Uint8Array(digest);
      }

      async function hkdfSha256(ikm, info, outputLengthBytes) {
        const key = await crypto.subtle.importKey('raw', ikm, 'HKDF', false, [
          'deriveBits'
        ]);
        const bits = await crypto.subtle.deriveBits(
          {
            name: 'HKDF',
            hash: 'SHA-256',
            salt: new Uint8Array(),
            info
          },
          key,
          outputLengthBytes * 8
        );
        return new Uint8Array(bits);
      }

      async function hmacSha256(keyBytes, data) {
        const key = await crypto.subtle.importKey(
          'raw',
          keyBytes,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign']
        );
        const signature = await crypto.subtle.sign('HMAC', key, data);
        return new Uint8Array(signature);
      }

      async function hashToScalar(passwordBytes) {
        const okm = await hkdfSha256(passwordBytes, encoder.encode('SPAKE2 pw'), 48);
        const wideScalarBytes = new Uint8Array(64);
        for (let i = 0; i < 48; i += 1) {
          wideScalarBytes[47 - i] = okm[i];
        }
        return modOrder(bytesToBigIntLe(wideScalarBytes));
      }

      async function hashAb(passwordBytes, idA, idB, firstMessage, secondMessage, keyBytes) {
        const transcript = new Uint8Array(192);
        transcript.set(await sha256(passwordBytes), 0);
        transcript.set(await sha256(idA), 32);
        transcript.set(await sha256(idB), 64);
        transcript.set(firstMessage, 96);
        transcript.set(secondMessage, 128);
        transcript.set(keyBytes, 160);
        return sha256(transcript);
      }

      async function buildProof(sharedKey, context, enrollmentId, publicKeyBytes) {
        const proofInput = concatBytes(
          context,
          parseUuidBytes(enrollmentId),
          publicKeyBytes
        );
        return hmacSha256(sharedKey, proofInput);
      }

      async function postJson(path, payload) {
        const response = await fetch(path, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const text = await response.text();
        let json = null;
        if (text) {
          try {
            json = JSON.parse(text);
          } catch (_error) {
            json = null;
          }
        }
        return { response, text, json };
      }

      function unwrapApiData(result, stepName) {
        if (!result.response.ok) {
          throw new Error(`${stepName} failed (${result.response.status}): ${result.text}`);
        }
        if (!result.json || result.json.success !== true || !('data' in result.json)) {
          throw new Error(`${stepName} returned an unexpected response body: ${result.text}`);
        }
        return result.json.data;
      }

      async function runE2e() {
        runButton.disabled = true;
        resetOutput();

        try {
          const password = passwordInput.value;
          if (!password.trim()) {
            throw new Error('Enrollment password is required.');
          }

          const privateKey = ed25519.utils.randomSecretKey();
          const publicKey = ed25519.getPublicKey(privateKey);
          const publicKeyB64 = bytesToBase64(publicKey);
          const privateKeyB64 = bytesToBase64(privateKey);
          publicKeyField.value = publicKeyB64;
          privateKeyField.value = privateKeyB64;
          log('Generated browser key pair.');

          const x = randomScalar();
          const passwordBytes = encoder.encode(password);
          const pw = await hashToScalar(passwordBytes);
          const clientPoint = ed25519.ExtendedPoint.BASE
            .multiply(x)
            .add(SPAKE2_M.multiply(pw));
          const clientMessage = concatBytes(Uint8Array.of(0x41), clientPoint.toRawBytes());
          const clientMessageB64 = bytesToBase64(clientMessage);
          log('Built SPAKE2 client message.');

          const startResult = await postJson('/api/auth/trusted-keys/spake2/start', {
            client_message_b64: clientMessageB64
          });
          const startData = unwrapApiData(startResult, 'SPAKE2 start');
          const enrollmentId = startData.enrollment_id;
          const serverMessageBytes = base64ToBytes(startData.server_message_b64);
          enrollmentIdField.value = enrollmentId;
          log(`SPAKE2 start accepted. enrollment_id=${enrollmentId}`);

          if (serverMessageBytes.length !== 33 || serverMessageBytes[0] !== 0x42) {
            throw new Error('Server SPAKE2 message has invalid format.');
          }
          const serverPoint = ed25519.ExtendedPoint.fromHex(serverMessageBytes.slice(1));
          const unblinding = SPAKE2_N.multiply(scalarNeg(pw));
          const keyPoint = serverPoint.add(unblinding).multiply(x);
          const sharedKey = await hashAb(
            passwordBytes,
            CLIENT_ID,
            SERVER_ID,
            clientMessage.slice(1),
            serverMessageBytes.slice(1),
            keyPoint.toRawBytes()
          );
          log('Derived SPAKE2 shared key.');

          const clientProof = await buildProof(
            sharedKey,
            CLIENT_PROOF_CONTEXT,
            enrollmentId,
            publicKey
          );

          const finishResult = await postJson('/api/auth/trusted-keys/spake2/finish', {
            enrollment_id: enrollmentId,
            public_key_b64: publicKeyB64,
            client_proof_b64: bytesToBase64(clientProof)
          });
          const finishData = unwrapApiData(finishResult, 'SPAKE2 finish');
          log(`SPAKE2 finish accepted. added=${String(finishData.added)}`);

          const expectedServerProof = await buildProof(
            sharedKey,
            SERVER_PROOF_CONTEXT,
            enrollmentId,
            publicKey
          );
          const providedServerProof = base64ToBytes(finishData.server_proof_b64);
          if (!equalBytes(expectedServerProof, providedServerProof)) {
            throw new Error('Server proof mismatch.');
          }
          log('Verified server proof.');

          const timestamp = Math.floor(Date.now() / 1000);
          const signedPath = '/api/auth/signed-test';
          const message = encoder.encode(`${timestamp}.POST.${signedPath}`);
          const signature = ed25519.sign(message, privateKey);
          const signatureB64 = bytesToBase64(signature);

          const signedResponse = await fetch(signedPath, {
            method: 'POST',
            headers: {
              'x-vk-timestamp': String(timestamp),
              'x-vk-signature': signatureB64
            }
          });
          const signedBodyText = await signedResponse.text();
          log(
            `Signed test response: status=${signedResponse.status} body=${signedBodyText}`
          );

          if (!signedResponse.ok) {
            throw new Error('Signed test endpoint rejected the request.');
          }

          log('E2E flow completed successfully.');
        } finally {
          runButton.disabled = false;
        }
      }
    </script>
  </body>
</html>
