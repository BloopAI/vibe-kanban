# Архитектура Preview Proxy: анализ проблемы cookie/origin и известные ограничения

## Содержание

1. [Обзор архитектуры](#1-обзор-архитектуры)
2. [Анализ cookie и origin](#2-анализ-cookie-и-origin)
   - [Same-Origin Policy и cookie](#21-same-origin-policy-и-cookie)
   - [Решает ли наш прокси эту проблему?](#22-решает-ли-наш-subdomain-прокси-эту-проблему)
   - [Итоговая оценка](#23-итоговая-оценка)
3. [Архитектурные недостатки](#3-архитектурные-недостатки)
4. [Рекомендации по улучшению](#4-рекомендации-по-улучшению)
5. [Ссылки на файлы](#5-ссылки-на-файлы)

---

## 1. Обзор архитектуры

Система превью в Vibe Kanban позволяет просматривать запущенные dev-серверы прямо внутри основного интерфейса приложения. Ключевые компоненты:

- **Приложение Vibe Kanban**: работает на `http://localhost:3001`
- **Preview proxy сервер**: работает на `http://localhost:9099`
- **URL превью в iframe**: `http://{devPort}.localhost:{proxyPort}/path`
  - Пример: `http://3000.localhost:9099/` проксирует запросы на `http://localhost:3000/`

Когда пользователь открывает превью, прокси перехватывает HTML-ответы и внедряет четыре скрипта:

1. **bippy_bundle** (инспекция React fiber tree через DevTools-хуки)
2. **eruda_init** (мобильная консоль разработчика)
3. **devtools_script** (определение фреймворка и диагностика)
4. **click_to_component_script** (клик по элементу для поиска исходного компонента)

Коммуникация между iframe (превью) и родительским окном (Vibe Kanban) происходит через `postMessage`. Прокси также пробрасывает WebSocket-соединения для HMR (Hot Module Replacement).

```
┌──────────────────────────────────────────────────────────────────┐
│  Vibe Kanban App (http://localhost:3001)                         │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │  <iframe src="http://3000.localhost:9099/">                │  │
│  │                                                            │  │
│  │    Браузер видит origin: http://3000.localhost:9099        │  │
│  │    Прокси перенаправляет: http://localhost:3000            │  │
│  │                                                            │  │
│  │    Внедрён: bippy_bundle.js                                │  │
│  │    Внедрён: eruda_init.js                                  │  │
│  │    Внедрён: devtools_script.js                             │  │
│  │    Внедрён: click_to_component_script.js                   │  │
│  │                                                            │  │
│  └────────────────────────────────────────────────────────────┘  │
│                          ▲                                       │
│                          │ postMessage('*')                      │
│                          ▼                                       │
│  Родительское окно получает данные о компонентах, навигации и пр.│
└──────────────────────────────────────────────────────────────────┘
```

Каждый dev-сервер получает собственный поддомен, что обеспечивает изоляцию на уровне origin для JavaScript API. Но с cookie всё значительно сложнее.

---

## 2. Анализ cookie и origin

Это центральный раздел документа. Cookie и origin подчиняются разным правилам в браузерах, и понимание этого различия критически важно для оценки нашей прокси-архитектуры.

### 2.1 Same-Origin Policy и cookie

**Origin** в контексте безопасности браузера означает схему + хост + порт. Вот три разных origin:

- `http://localhost:3000`
- `http://localhost:3001`
- `http://localhost:9099`

JavaScript, работающий в одном origin, не может читать DOM, хранилище или сетевые ответы другого origin. Это Same-Origin Policy, фундамент веб-безопасности.

**Cookie подчиняются другим правилам.** Это ключевое различие.

Cookie сопоставляются по **домену** и **пути**. Порт не имеет значения. Согласно RFC 6265, раздел 8.5:

> *«Cookies do not provide isolation by port. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server.»*

Что это означает на практике:

- `http://localhost:3000` устанавливает cookie: `session=abc; Domain=localhost; Path=/`
- `http://localhost:3001` **может прочитать эту cookie**, потому что `Domain=localhost` совпадает для обоих
- `http://localhost:5173` тоже может её прочитать
- Все dev-серверы на всех портах делят одну и ту же банку cookie для `localhost`

Реальные последствия:

- **Сессии аутентификации утекают между проектами.** Если Проект A устанавливает сессионную cookie на `localhost`, dev-сервер Проекта B может её прочитать.
- **CSRF-токены конфликтуют.** Два приложения с одинаковым именем CSRF-cookie будут перезаписывать токены друг друга.
- **Хранилища сессий мешают друг другу.** Выход из одного проекта может инвалидировать сессии в другом, если они используют общее хранилище, привязанное к cookie.

Это не теоретическая проблема. Любой разработчик, запускающий несколько dev-серверов одновременно, наверняка сталкивался с загадочными ошибками аутентификации из-за коллизий cookie.

### 2.2 Решает ли наш subdomain-прокси эту проблему?

Наш прокси переписывает URL так, что `localhost:3000` превращается в `3000.localhost:9099`. Вопрос: решает ли это проблему с cookie?

**Как браузеры обрабатывают поддомены `localhost`:**

Современные браузеры (Chrome 94+, Firefox 84+, Safari 15+) считают `localhost` специальным доменом. Поддомен `3000.localhost` распознаётся как отдельное имя хоста, отличное от `5173.localhost`. Однако обработка cookie для поддоменов `localhost` непоследовательна между браузерами, и детали имеют значение.

**Анализ сценариев:**

| Кто устанавливает cookie | Атрибут Domain | Доступна из `3000.localhost:9099`? | Доступна из `5173.localhost:9099`? |
|---|---|---|---|
| `localhost:3000` | `Domain=localhost` | Зависит от браузера | Зависит от браузера |
| `localhost:3000` | (без атрибута Domain) | Нет (host-only cookie) | Нет |
| `3000.localhost:9099` | `Domain=.localhost` | Да | Да (УТЕЧКА!) |
| `3000.localhost:9099` | `Domain=3000.localhost` | Да | Нет (изолирована) |
| `3000.localhost:9099` | (без атрибута Domain) | Да | Нет (host-only) |

Разберём каждую строку подробно.

**Строка 1: Dev-сервер устанавливает `Domain=localhost`.**
Оригинальный dev-сервер на `localhost:3000` устанавливает cookie с явным `Domain=localhost`. Через прокси браузер получает этот заголовок `Set-Cookie`, но ассоциирует его с доменом прокси (`3000.localhost`). Примет ли браузер cookie с `Domain=localhost`, когда запрос был к `3000.localhost`, зависит от правил сопоставления доменов. Большинство браузеров примут, потому что `3000.localhost` является поддоменом `localhost`. Эта cookie становится видимой для ВСЕХ поддоменов `*.localhost`. Это утечка.

**Строка 2: Dev-сервер не указывает атрибут Domain.**
Без явного Domain cookie становится «host-only» для точного имени хоста, к которому обращался браузер. Поскольку браузер обращался к `3000.localhost`, cookie привязана к `3000.localhost`. Другие поддомены её не видят. Это безопасный случай.

**Строка 3: Скрипт на стороне прокси устанавливает `Domain=.localhost`.**
Если любой JavaScript, работающий на `3000.localhost`, явно устанавливает `document.cookie` с `Domain=.localhost`, эта cookie становится общей для всех поддоменов `*.localhost`. Межпроектная утечка.

**Строка 4: Скрипт на стороне прокси устанавливает `Domain=3000.localhost`.**
Правильная область видимости. Только `3000.localhost` может её прочитать.

**Строка 5: Скрипт на стороне прокси не указывает Domain.**
Host-only cookie для `3000.localhost`. Безопасно и изолированно.

**Осложнение с Public Suffix List:**

Chrome и Firefox поддерживают Public Suffix List (PSL), который определяет, какие домены являются «регистрируемыми», а какие «публичными суффиксами». Публичный суффикс — это домен, под которым кто угодно может регистрировать поддомены (например, `.com`, `.co.uk`).

`localhost` рассматривается как публичный суффикс в некоторых реализациях браузеров. Когда домен находится в PSL, браузеры отклоняют cookie с `Domain=.localhost`, потому что установка cookie на публичном суффиксе затронула бы все поддомены, что является угрозой безопасности.

Для нашей архитектуры это на самом деле *хорошо*. Если браузер отклоняет cookie с `Domain=.localhost`, это предотвращает сценарий утечки из строки 3. Но это поведение зависит от конкретного браузера и не гарантировано.

**Проблема перезаписи домена cookie:**

Есть более тонкий момент. Когда dev-сервер на `localhost:3000` отправляет ответ с `Set-Cookie: session=abc; Domain=localhost; Path=/`, прокси пересылает этот заголовок без изменений. Но браузер получил этот ответ от `3000.localhost:9099`, а не от `localhost:3000`.

Браузер должен решить: принимать ли cookie с `Domain=localhost` из ответа, пришедшего от `3000.localhost`? Правила сопоставления доменов говорят «да» (поддомен может устанавливать cookie для родительского домена, если тот не является публичным суффиксом). Но cookie теперь ассоциирована с `localhost`, а не с `3000.localhost`, то есть она доступна всем портам и поддоменам.

Прокси не перезаписывает заголовки `Set-Cookie`. Он не модифицирует атрибут `Domain` для соответствия поддомену прокси. Это означает, что cookie, предназначенные dev-сервером для `localhost`, оказываются в неоднозначном состоянии.

```
┌─────────────────────────────────────────────────────────────┐
│ Банка cookie браузера                                       │
│                                                             │
│  Domain: localhost         → общий для ВСЕХ портов localhost│
│    session=abc             ⚠️ УТЕЧКА между проектами        │
│                                                             │
│  Domain: 3000.localhost    → изолирован для проекта A       │
│    auth_token=xyz          ✅ Безопасно, видит только A     │
│                                                             │
│  Domain: 5173.localhost    → изолирован для проекта B       │
│    auth_token=def          ✅ Безопасно, видит только B     │
│                                                             │
│  Domain: .localhost        → ОБЩИЙ для ВСЕХ поддоменов      │
│    tracking=ghi            ⚠️ УТЕЧКА, Chrome может отклонить│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Итоговая оценка

**Архитектура subdomain-прокси частично решает проблему cookie.**

Что работает:

- **Host-only cookie изолированы.** Cookie, установленные без явного атрибута `Domain` (самый распространённый случай в современных фреймворках), привязаны к конкретному поддомену (`3000.localhost`). Они не утекают в `5173.localhost`. Это покрывает большинство сценариев использования cookie при разработке.
- **JavaScript-хранилища полностью изолированы.** `localStorage`, `sessionStorage` и IndexedDB привязаны к origin (схема + хост + порт). У `3000.localhost:9099` и `5173.localhost:9099` полностью раздельные хранилища. Это реальное преимущество.
- **Проверки origin работают корректно.** Верификация origin в `postMessage`, `document.domain` и `window.opener` видят различные origin для каждого dev-сервера.

Что не работает:

- **Заголовки `Set-Cookie` dev-сервера привязываются к неправильному домену.** Браузер ассоциирует cookie из ответа dev-сервера с доменом прокси, а не с оригинальным `localhost:{port}`. Потоки аутентификации, зависящие от отправки cookie обратно на `localhost:{port}`, ломаются, потому что браузер отправляет их на `3000.localhost:9099`.
- **Cookie с `Domain=.localhost` утекают.** Если любой код устанавливает cookie с `Domain=.localhost`, она видна всем поддоменам. Поведение PSL в браузере может это заблокировать, но гарантий нет.
- **Прокси не перехватывает заголовки `Set-Cookie`.** Никакой перезаписи не происходит ни в одном направлении. Домены cookie проходят без изменений, создавая описанное выше несоответствие.

Сводная таблица:

| Аспект | Статус | Примечания |
|---|---|---|
| Изоляция origin (JS) | ✅ Решено | postMessage, document.domain, window.opener |
| Изоляция хранилищ | ✅ Решено | localStorage, sessionStorage, IndexedDB |
| Обход CSP/X-Frame-Options | ✅ Решено | Заголовки удаляются прокси |
| Внедрение скриптов | ✅ Решено | DevTools, навигация, click-to-component |
| Изоляция cookie (host-only) | ✅ В основном решено | Работает, когда Domain не указан явно |
| Изоляция cookie (Domain=localhost) | ⚠️ Частично | Зависит от браузера, PSL может помочь |
| Изоляция cookie (Domain=.localhost) | ⚠️ Утечка | Chrome/Firefox PSL могут отклонить |
| Auth-cookie dev-сервера | ❌ Сломано | Несоответствие домена через прокси |
| Области Service Worker | ❌ Не решено | Все под localhost |
| Персистентность `window.name` | ❌ Не решено | Общий между навигациями |

---

## 3. Архитектурные недостатки

Помимо проблемы с cookie, прокси-архитектура имеет ряд структурных ограничений, которые стоит задокументировать.

### 3.1 Безусловное внедрение скриптов

Все четыре скрипта (bippy_bundle, eruda_init, devtools_script, click_to_component_script) внедряются в каждый HTML-ответ. Никакой условной логики нет.

**Влияние на производительность.** Суммарный объём составляет примерно 800 КБ+ JavaScript. Один только bippy_bundle весит немало. Каждая загрузка страницы, каждый HTML-ответ, каждая навигация внутри iframe несёт эти затраты.

**Бесполезная работа.** VKBippy устанавливает хуки React DevTools. На странице с Vue, Svelte или чистым HTML эта работа полностью бессмысленна. Хуки просто занимают память и потенциально мешают собственным инструментам страницы.

**Риск конфликтов.** Внедрённые скрипты могут конфликтовать с собственными скриптами dev-сервера. Если у разработчика установлено расширение React DevTools в браузере, инспекция fiber tree от VKBippy может с ним столкнуться. Две системы, пытающиеся инструментировать одно и то же дерево React fiber, создают почву для трудноуловимых багов.

**Зависимость от CDN.** Eruda загружается с внешнего CDN при каждой загрузке страницы. Если CDN недоступен (корпоративный файрвол, офлайн-разработка, сбой CDN), eruda не загружается. Страница продолжает работать, но консоль разработчика пропадает без объяснений.

Лучший подход: определять фреймворк на уровне прокси, сканируя HTML-контент на наличие маркеров (корневые элементы React, точки монтирования Vue, сигнатуры компонентов Svelte), и внедрять только релевантные скрипты.

### 3.2 Полная буферизация HTML

Прокси буферизует весь HTML-ответ в памяти перед внедрением скриптов и отправкой клиенту.

**Нагрузка на память.** Большие HTML-страницы (SPA со значительным объёмом встроенных данных, серверно-отрендеренные страницы с вложенными JSON-пейлоадами) потребляют память прокси пропорционально своему размеру. Жёстко заданный лимит в 50 МБ ограничивает это, но 50 МБ на запрос всё равно много.

**Задержка.** Time-to-first-byte (TTFB) увеличивается, потому что клиент ничего не получает, пока прокси не получит полный ответ, не внедрит скрипты и не начнёт пересылку. Для потокового SSR (Server-Side Rendering) это критично. Фреймворки вроде Next.js и Remix могут отправлять HTML-чанки прогрессивно. Прокси убивает эту возможность, буферизуя всё целиком.

**Решение** — потоковый HTML-парсер, который отслеживает теги `<head>` или `<body>`, внедряет скрипты в нужную позицию и пропускает всё остальное без изменений. Реализация значительно сложнее, но сохраняет потоковый SSR и снижает TTFB.

### 3.3 Отсутствие поддержки HTTPS

Прокси обрабатывает только `http://`-соединения. Dev-серверы, работающие по HTTPS, не поддерживаются.

На практике это менее серьёзно, чем кажется. Большинство браузеров считают `localhost` безопасным контекстом независимо от схемы, поэтому API вроде Web Crypto, Geolocation и Notifications продолжают работать. Service Workers — главное исключение: они требуют HTTPS в продакшене, и хотя `localhost` получает исключение, поддомен прокси (`3000.localhost`) может не получить его во всех браузерах.

Предупреждения о смешанном контенте также могут появиться, если основное приложение Vibe Kanban когда-нибудь перейдёт на HTTPS, а превью останутся на HTTP.

### 3.4 Архитектура одного хоста

Прокси перенаправляет только на `localhost:{port}`. Предполагается, что dev-сервер работает на той же машине.

Это ломается для:

- **Docker-разработки.** Dev-серверы внутри контейнеров работают на других сетевых интерфейсах. `localhost` внутри контейнера — это не `localhost` на хосте.
- **Удалённой разработки.** SSH-туннели, WSL2 (у которого собственное сетевое пространство имён) и облачные среды разработки — во всех этих случаях dev-сервер может быть недоступен по `127.0.0.1`.
- **IPv6.** Поддерживается только IPv4 `localhost` (127.0.0.1). `[::1]` не работает.

### 3.5 Отсутствие перезаписи редиректов

Прокси использует `redirect(Policy::none())`, пропуская ответы-редиректы без модификации.

Проблема: если dev-сервер на `localhost:3000` перенаправляет с `/` на `/login`, он отправляет `302` с `Location: http://localhost:3000/login`. Прокси пересылает этот заголовок без изменений. Браузер следует редиректу на `localhost:3000/login` напрямую, минуя прокси.

Iframe превью внезапно уходит с URL прокси на прямой URL dev-сервера. Внедрённые скрипты пропадают. Коммуникация через postMessage ломается. Превью фактически перестаёт работать.

```
┌─────────────────────────────────────────────────────────────┐
│  Поток редиректа (текущий, сломанный)                       │
│                                                             │
│  Браузер → GET http://3000.localhost:9099/                  │
│  Прокси  → GET http://localhost:3000/                       │
│  Сервер  → 302 Location: http://localhost:3000/login        │
│  Прокси  → 302 Location: http://localhost:3000/login        │
│  Браузер → GET http://localhost:3000/login  ← МИНУЕТ ПРОКСИ│
│                                                             │
│  Поток редиректа (исправленный)                             │
│                                                             │
│  Браузер → GET http://3000.localhost:9099/                  │
│  Прокси  → GET http://localhost:3000/                       │
│  Сервер  → 302 Location: http://localhost:3000/login        │
│  Прокси  → 302 Location: http://3000.localhost:9099/login   │
│  Браузер → GET http://3000.localhost:9099/login ← ОСТАЁТСЯ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Решение: перезаписывать заголовки `Location` в 3xx-ответах, заменяя `localhost:{port}` на `{port}.localhost:{proxyPort}`.

### 3.6 Обработка путей WebSocket

WebSocket-соединения проксируются на `ws://localhost:{port}/{path}`, но некоторые dev-серверы (особенно Vite) используют специфические пути WebSocket для HMR с параметрами запроса.

Vite, например, использует `/__vite_hmr` или `/_vite/hmr` с определёнными query-параметрами. Если прокси не сохраняет их в точности, HMR ломается. Резервная маршрутизация частично смягчает проблему, но граничные случаи существуют, особенно с dev-серверами, которые согласовывают WebSocket-апгрейд на нестандартных путях.

### 3.7 Svelte 5 Runes: невозможность обнаружения

Svelte 5 с режимом runes намеренно удалил `__svelte_meta` (issue #11389 в репозитории Svelte). Метода обнаружения Svelte 5 runes-компонентов в рантайме не существует.

Функция click-to-component опирается на метаданные рантайма для сопоставления DOM-элементов с исходными компонентами. Без `__svelte_meta` адаптер Svelte не может найти границы компонентов или расположение в исходном коде. По мере того как Svelte 5 runes становится режимом по умолчанию, этот адаптер перестанет работать для новых проектов на Svelte.

Это не баг в нашем коде. Это осознанное решение разработчиков фреймворка, усложняющее работу внешних инструментов.

### 3.8 Номера строк Vue

Рантайм Vue 3 предоставляет путь к файлу компонента через `instance.type.__file`, но не номера строк в исходном коде. Пользователи видят, в каком файле находится компонент, но не на какой строке.

Для небольших однофайловых компонентов пути к файлу достаточно. Для больших SFC с сотнями строк это значительно менее полезно. Получение номеров строк потребовало бы плагина сборки вроде `unplugin-vue-source`, который встраивает source maps или метаданные строк на этапе компиляции. Это вне контроля прокси.

### 3.9 PostMessage с wildcard origin

Все вызовы `postMessage` используют `window.parent.postMessage(msg, '*')` с wildcard-origin.

В текущей архитектуре, ограниченной localhost, это допустимо. Любое окно на той же машине может получить эти сообщения, но поверхность атаки минимальна. Для удалённых или облачных развёртываний, однако, wildcard означает, что любое родительское окно может перехватить данные об обнаружении компонентов, событиях навигации и диагностическую информацию.

Исправление простое: заменить `'*'` на конкретный origin URL Vibe Kanban (например, `http://localhost:3001`). Для этого внедряемые скрипты должны знать origin родителя, который можно передать как параметр конфигурации при внедрении.

### 3.10 Race condition при определении фреймворка

`detectFrameworks()` запускается по событию `DOMContentLoaded`, но некоторые фреймворки к этому моменту ещё не полностью инициализированы. React с ленивой загрузкой, Vue с асинхронными компонентами и любой фреймворк, откладывающий инициализацию, будут пропущены.

Диагностический лог может показать `[vk-ctc] Detected frameworks: none`, хотя фреймворк загрузится через мгновение. Это вводит в заблуждение, но функционально ничего не ломает: фактическая диспетчеризация адаптера происходит при каждом клике, когда фреймворк обычно уже инициализирован. Лог обнаружения носит чисто диагностический характер.

---

## 4. Рекомендации по улучшению

Упорядочены по приоритету и влиянию:

| Приоритет | Улучшение | Трудоёмкость | Влияние |
|---|---|---|---|
| **ВЫСОКИЙ** | Перезапись URL в редиректах | Низкая | Исправляет сломанную навигацию в превью |
| **ВЫСОКИЙ** | Ограничение origin в postMessage | Низкая | Усиление безопасности для удалённых развёртываний |
| **СРЕДНИЙ** | Условное внедрение скриптов | Средняя | ~800 КБ меньше JS на не-React страницах |
| **СРЕДНИЙ** | Перезапись домена в Set-Cookie | Средняя | Исправляет потоки аутентификации через прокси |
| **НИЗКИЙ** | Потоковое внедрение в HTML | Высокая | Сохраняет потоковый SSR, снижает TTFB |
| **НИЗКИЙ** | Поддержка HTTPS в прокси | Высокая | Включает API, требующие безопасного контекста |

### Перезапись URL в редиректах (ВЫСОКИЙ)

Перехватывать 3xx-ответы и перезаписывать заголовки `Location`. Заменять `http://localhost:{port}/path` на `http://{port}.localhost:{proxyPort}/path`. Это небольшое изменение с непропорционально большим эффектом: без него любой dev-сервер, использующий редиректы (потоки логина, OAuth-коллбэки, гарды маршрутов), ломает превью.

### Ограничение origin в postMessage (ВЫСОКИЙ)

Заменить `'*'` на origin приложения Vibe Kanban во всех вызовах `postMessage`. Передавать origin как переменную при внедрении скриптов. Минимальные усилия, ощутимое улучшение безопасности.

### Условное внедрение скриптов (СРЕДНИЙ)

Перед внедрением скриптов сканировать HTML-ответ на наличие маркеров фреймворков. Внедрять bippy_bundle только при обнаружении маркеров React. Внедрять код обнаружения, специфичный для фреймворка, только для обнаруженных фреймворков. Eruda можно сделать опциональным, а не включённым по умолчанию.

### Перезапись домена в Set-Cookie (СРЕДНИЙ)

Перехватывать заголовки `Set-Cookie` в ответах и перезаписывать `Domain=localhost` на `Domain={port}.localhost`. Это гарантирует, что cookie, установленные dev-сервером, правильно привязаны к поддомену прокси. Также перехватывать исходящие заголовки `Cookie` в запросах и выполнять обратную перезапись, чтобы dev-сервер видел ожидаемые cookie.

### Потоковое внедрение в HTML (НИЗКИЙ)

Заменить подход с полной буферизацией на потоковый HTML-парсер. Отслеживать теги `<head>` или `</head>` в потоке, внедрять скрипты в нужную позицию и пропускать всё остальное без изменений. Это сохраняет потоковый SSR и снижает TTFB. Реализация сложна (обработка chunked transfer encoding, частичных границ тегов), но выигрыш значителен для пользователей Next.js/Remix.

### Поддержка HTTPS в прокси (НИЗКИЙ)

Добавить TLS-терминацию в прокси или поддержку проксирования на HTTPS dev-серверы. Низкий приоритет, потому что `localhost` уже считается безопасным контекстом в большинстве браузеров, но становится важным для облачных/удалённых развёртываний.

---

## 5. Ссылки на файлы

| Файл | Строк | Назначение |
|---|---|---|
| `crates/server/src/preview_proxy/mod.rs` | ~407 | Основная реализация прокси-сервера |
| `frontend/src/components/ui-new/containers/PreviewBrowserContainer.tsx` | - | Построение URL для iframe превью на фронтенде |
| `crates/server/src/preview_proxy/bippy_bundle.js` | - | Скрипт инспекции React fiber |
| `crates/server/src/preview_proxy/eruda_init.js` | - | Инициализация мобильной консоли разработчика |
| `crates/server/src/preview_proxy/devtools_script.js` | - | Определение фреймворка и диагностика |
| `crates/server/src/preview_proxy/click_to_component_script.js` | - | Сопоставление клика с исходным компонентом |
